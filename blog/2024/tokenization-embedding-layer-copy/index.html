<!DOCTYPE html> <html lang="en"> <head> <meta http-equiv="Content-Type" content="text/html; charset=UTF-8"> <meta charset="utf-8"> <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"> <meta http-equiv="X-UA-Compatible" content="IE=edge"> <title> Heap vs. Stack Memory in Java | Yuanlai He (Miles) </title> <meta name="author" content="Miles (Yuanlai) Ho"> <meta name="description" content="Understanding the difference between heap and stack memory in Java"> <meta name="keywords" content="Software Development Engineer"> <link rel="stylesheet" href="/assets/css/bootstrap.min.css?a4b3f509e79c54a512b890d73235ef04"> <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/mdbootstrap@4.20.0/css/mdb.min.css" integrity="sha256-jpjYvU3G3N6nrrBwXJoVEYI/0zw8htfFnhT9ljN3JJw=" crossorigin="anonymous"> <link defer rel="stylesheet" href="https://unpkg.com/bootstrap-table@1.22.1/dist/bootstrap-table.min.css"> <link rel="stylesheet" href="/assets/css/academicons.min.css?f0b7046b84e425c55f3463ac249818f5"> <link rel="stylesheet" type="text/css" href="https://fonts.googleapis.com/css?family=Roboto:300,400,500,700|Roboto+Slab:100,300,400,500,700|Material+Icons"> <link rel="stylesheet" href="/assets/css/jekyll-pygments-themes-github.css?591dab5a4e56573bf4ef7fd332894c99" media="" id="highlight_theme_light"> <link href="/assets/css/bootstrap-toc.min.css?6f5af0bb9aab25d79b2448143cbeaa88" rel="stylesheet"> <link rel="shortcut icon" href="/assets/img/command-line.png?0c818eda30e553ba2f0d187ca37db021"> <link rel="stylesheet" href="/assets/css/main.css?d41d8cd98f00b204e9800998ecf8427e"> <link rel="canonical" href="https://imilesho.github.io/blog/2024/tokenization-embedding-layer-copy/"> <link rel="stylesheet" href="/assets/css/jekyll-pygments-themes-native.css?5847e5ed4a4568527aa6cfab446049ca" media="none" id="highlight_theme_dark"> <script src="/assets/js/theme.js?bf50d6d9dd867d3e0f3b0add94449649"></script> </head> <body class="fixed-top-nav "> <header> <nav id="navbar" class="navbar navbar-light navbar-expand-sm fixed-top" role="navigation"> <div class="container"> <a class="navbar-brand title font-weight-lighter" href="/"> Yuanlai He (Miles) </a> <button class="navbar-toggler collapsed ml-auto" type="button" data-toggle="collapse" data-target="#navbarNav" aria-controls="navbarNav" aria-expanded="false" aria-label="Toggle navigation"> <span class="sr-only">Toggle navigation</span> <span class="icon-bar top-bar"></span> <span class="icon-bar middle-bar"></span> <span class="icon-bar bottom-bar"></span> </button> <div class="collapse navbar-collapse text-right" id="navbarNav"> <ul class="navbar-nav ml-auto flex-nowrap"> <li class="nav-item "> <a class="nav-link" href="/">about </a> </li> <li class="nav-item "> <a class="nav-link" href="/blog/">blog </a> </li> <li class="nav-item "> <a class="nav-link" href="/cv/">Resume </a> </li> <li class="nav-item "> <a class="nav-link" href="/projects/">projects </a> </li> <li class="nav-item "> <a class="nav-link" href="/publications/">publications </a> </li> <li class="toggle-container"> <button id="light-toggle" title="Change theme"> <i class="fa-solid fa-moon"></i> <i class="fa-solid fa-sun"></i> </button> </li> </ul> </div> </div> </nav> <progress id="progress" value="0"> <div class="progress-container"> <span class="progress-bar"></span> </div> </progress> </header> <div class="container mt-5" role="main"> <div class="row"> <div class="col-sm-3"> <nav id="toc-sidebar" class="sticky-top"></nav> </div> <div class="col-sm-9"> <div class="post"> <header class="post-header"> <h1 class="post-title">Heap vs. Stack Memory in Java</h1> <p class="post-meta"> February 15, 2024 </p> <p class="post-tags"> <a href="/blog/2024"> <i class="fa-solid fa-calendar fa-sm"></i> 2024 </a>   ·   <a href="/blog/tag/java"> <i class="fa-solid fa-hashtag fa-sm"></i> Java</a>   <a href="/blog/tag/memorymanagement"> <i class="fa-solid fa-hashtag fa-sm"></i> MemoryManagement</a>     ·   <a href="/blog/category/notes"> <i class="fa-solid fa-tag fa-sm"></i> notes</a>   </p> </header> <article class="post-content"> <div id="markdown-content"> <p>Understanding the difference between the heap and the stack is fundamental to grasping how Java manages memory. Both the heap and the stack are parts of the memory used by a Java Virtual Machine (JVM), but they serve different purposes and have different behaviors.</p> <h2 id="stack">Stack</h2> <p><strong>Functionality</strong>: The stack is used for managing and executing thread execution. It stores primitive values that are specific to a method and references to objects in the heap that are referred to from the method.</p> <p><strong>Method Execution</strong>: When a method is called, a block (called a “stack frame”) is created on the stack. This block contains all the local variables and references used in the method, as well as the method’s call and return operations. Once the method has completed execution, its stack frame is removed from the stack.</p> <p><strong>Memory Management</strong>: Memory on the stack is automatically allocated and deallocated as methods are called and returned. This makes it very efficient, but the size of the stack is limited and is determined at the start of the application.</p> <p><strong>Lifespan</strong>: The stack has a very short lifespan. Variables only exist as long as the method that created them is running.</p> <h2 id="heap">Heap</h2> <p><strong>Functionality</strong>: The heap is used to store objects (instances of classes) and their attributes. It is where all the objects created by your Java application live.</p> <p><strong>Memory Allocation</strong>: Unlike the stack, memory allocation in the heap is dynamically managed. New objects are created in the heap, and Java’s garbage collector automatically removes objects that are no longer being used to free up memory.</p> <p><strong>Lifespan</strong>: Objects on the heap have a longer lifespan. They exist as long as there are references to them from other objects or from the stack. Once there are no more references to an object, it becomes eligible for garbage collection.</p> <p><strong>Performance</strong>: While the heap allows for dynamic memory allocation, managing it (especially the garbage collection process) can be more complex and slower compared to stack memory management.</p> <h2 id="key-differences">Key Differences</h2> <p><strong>Speed</strong>: Stack memory is faster to allocate and deallocate, as it works with a Last In, First Out (LIFO) principle. Heap memory, being more dynamically managed, requires more complex bookkeeping.</p> <p><strong>Scope</strong>: Stack memory is exclusive to a thread, meaning each thread has its own stack. The heap is application-wide; all threads share it.</p> <p><strong>Size</strong>: Stack memory is usually much smaller than heap memory. The exact sizes can be configured based on the application’s needs.</p> <p><strong>Usage</strong>: Primitives and method call stacks are stored in the stack memory, while objects and their fields are stored in the heap memory.</p> <p>Understanding these differences is crucial for efficient Java programming, especially for managing memory effectively, optimizing performance, and avoiding memory leaks or stack overflow errors.</p> <h2 id="java-code-execution-process">Java Code Execution Process</h2> <h3 id="main-method-and-execution-start">Main Method and Execution Start</h3> <p>Program Entry Point: Yes, in a Java application, the main method serves as the entry point. When the program starts, the JVM initiates the execution of the main method.</p> <h4 id="method-area-and-code-storage">Method Area and Code Storage</h4> <p>Method Area Storage: The bytecode of the main method, like all methods, is stored in the Method Area of the JVM. This area holds the compiled code of all classes that have been loaded by the JVM, including methods, variable metadata, and other class information.</p> <h4 id="stack-and-method-execution">Stack and Method Execution</h4> <p>Stack Frames: When the main method is called, a stack frame is created on the stack for it. This stack frame is indeed at the bottom of the stack if main is the first method called. As more methods are called from main or elsewhere, additional frames are added to the stack for each method invocation.</p> <p><strong>Execution and Local Variables</strong>: The CPU, following the instructions provided by the JVM, executes the bytecode fetched from the Method Area. Execution does not happen directly in the stack; rather, the stack frame stores:</p> <p>Local variables and their values. Parameters passed to methods. Return addresses. Intermediate results of expressions. The CPU uses the stack frame for keeping track of method execution state, including which line of code is being executed and where to return after a method call completes. The actual execution involves the CPU reading instructions (bytecode) from the Method Area and manipulating data in registers, memory (including stack for local variables and heap for objects), and performing computations.</p> <h4 id="primitive-data-and-control-flow">Primitive Data and Control Flow</h4> <p><strong>Storage</strong>: Primitive data types used within a method are stored in the method’s stack frame. Control flow states, like the next instruction to execute or decisions made based on conditions (if, for, while statements), are managed through the program counter and CPU registers, with the stack frame supporting the method’s execution context.</p> <h4 id="correction-and-clarification">Correction and Clarification</h4> <p>Execution Handling: It’s more accurate to say that the CPU executes instructions based on the bytecode loaded into memory from the Method Area, with the JVM orchestrating the overall process. The stack is crucial for managing method calls and local data, but the actual “handling” or execution of statements involves the CPU processing instructions, utilizing various components of the computer’s architecture (including CPU registers and memory outside of just the stack).</p> <p>In summary, your interpretation is on the right track. The main method acts as the starting point, with its bytecode stored in the Method Area. Execution details, including local variables and control flow, are managed using stack frames, while the CPU, guided by the JVM, executes the bytecode instructions, utilizing both the stack and other system resources.</p> </div> </article> <br> <hr> <br> <ul class="list-disc pl-8"></ul> <h2 class="text-3xl font-semibold mb-4 mt-12">Enjoy Reading This Article?</h2> <p class="mb-2">Here are some more articles you might like to read next:</p> <li class="my-2"> <a class="text-pink-700 underline font-semibold hover:text-pink-800" href="/blog/2024/PythonReview/">Python Review Notes</a> </li> <li class="my-2"> <a class="text-pink-700 underline font-semibold hover:text-pink-800" href="/blog/2024/the-shell/">The Shell Command Line and File System Basics</a> </li> <li class="my-2"> <a class="text-pink-700 underline font-semibold hover:text-pink-800" href="/blog/2024/IAM-and-IAM-Identity-Center/">IAM and IAM Identity Center</a> </li> <div id="giscus_thread" style="max-width: 800px; margin: 0 auto;"> <script>let giscusTheme=localStorage.getItem("theme"),giscusAttributes={src:"https://giscus.app/client.js","data-repo":"iMilesHo/iMilesHo.github.io","data-repo-id":"R_kgDOLGyCuQ","data-category":"Announcements","data-category-id":"DIC_kwDOLGyCuc4Cch-l","data-mapping":"title","data-strict":"0","data-reactions-enabled":"1","data-emit-metadata":"0","data-input-position":"top","data-theme":giscusTheme,"data-lang":"en",crossorigin:"anonymous",async:""},giscusScript=document.createElement("script");Object.entries(giscusAttributes).forEach(([t,e])=>giscusScript.setAttribute(t,e)),document.getElementById("giscus_thread").appendChild(giscusScript);</script> <noscript>Please enable JavaScript to view the <a href="http://giscus.app/?ref_noscript" rel="external nofollow noopener" target="_blank">comments powered by giscus.</a> </noscript> </div> </div> </div> </div> </div> <footer class="fixed-bottom" role="contentinfo"> <div class="container mt-0"> © Copyright 2024 Miles (Yuanlai) Ho. </div> </footer> <script src="https://cdn.jsdelivr.net/npm/jquery@3.6.0/dist/jquery.min.js" integrity="sha256-/xUj+3OJU5yExlq6GSYGSHk7tPXikynS7ogEvDej/m4=" crossorigin="anonymous"></script> <script src="/assets/js/bootstrap.bundle.min.js"></script> <script src="https://cdn.jsdelivr.net/npm/mdbootstrap@4.20.0/js/mdb.min.js" integrity="sha256-NdbiivsvWt7VYCt6hYNT3h/th9vSTL4EDWeGs5SN3DA=" crossorigin="anonymous"></script> <script defer src="https://cdn.jsdelivr.net/npm/masonry-layout@4.2.2/dist/masonry.pkgd.min.js" integrity="sha256-Nn1q/fx0H7SNLZMQ5Hw5JLaTRZp0yILA/FRexe19VdI=" crossorigin="anonymous"></script> <script defer src="https://cdn.jsdelivr.net/npm/imagesloaded@4/imagesloaded.pkgd.min.js"></script> <script defer src="/assets/js/masonry.js" type="text/javascript"></script> <script defer src="https://cdn.jsdelivr.net/npm/medium-zoom@1.0.8/dist/medium-zoom.min.js" integrity="sha256-7PhEpEWEW0XXQ0k6kQrPKwuoIomz8R8IYyuU1Qew4P8=" crossorigin="anonymous"></script> <script defer src="/assets/js/zoom.js?85ddb88934d28b74e78031fd54cf8308"></script> <script defer src="/assets/js/bootstrap-toc.min.js?c82ff4de8b0955d6ff14f5b05eed7eb6"></script> <script defer src="https://unpkg.com/bootstrap-table@1.22.1/dist/bootstrap-table.min.js"></script> <script src="/assets/js/no_defer.js?2930004b8d7fcd0a8e00fdcfc8fc9f24"></script> <script defer src="/assets/js/common.js?4a129fbf39254905f505c7246e641eaf"></script> <script defer src="/assets/js/copy_code.js?7254ae07fe9cc5f3a10843e1c0817c9c" type="text/javascript"></script> <script async src="https://d1bxh8uas1mnw7.cloudfront.net/assets/embed.js"></script> <script async src="https://badge.dimensions.ai/badge.js"></script> <script type="text/javascript">window.MathJax={tex:{inlineMath:[["$","$"]],displayMath:[["$$","$$"]]},svg:{fontCache:"global"}};</script> <script defer type="text/javascript" id="MathJax-script" src="https://cdn.jsdelivr.net/npm/mathjax@3.2.0/es5/tex-mml-chtml.js"></script> <script defer src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script> <script type="text/javascript">function progressBarSetup(){"max"in document.createElement("progress")?(initializeProgressElement(),$(document).on("scroll",function(){progressBar.attr({value:getCurrentScrollPosition()})}),$(window).on("resize",initializeProgressElement)):(resizeProgressBar(),$(document).on("scroll",resizeProgressBar),$(window).on("resize",resizeProgressBar))}function getCurrentScrollPosition(){return $(window).scrollTop()}function initializeProgressElement(){let e=$("#navbar").outerHeight(!0);$("body").css({"padding-top":e}),$("progress-container").css({"padding-top":e}),progressBar.css({top:e}),progressBar.attr({max:getDistanceToScroll(),value:getCurrentScrollPosition()})}function getDistanceToScroll(){return $(document).height()-$(window).height()}function resizeProgressBar(){progressBar.css({width:getWidthPercentage()+"%"})}function getWidthPercentage(){return getCurrentScrollPosition()/getDistanceToScroll()*100}const progressBar=$("#progress");window.onload=function(){setTimeout(progressBarSetup,50)};</script> </body> </html>